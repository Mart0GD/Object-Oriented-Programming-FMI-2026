## Преход към C++. Разлики и новости.

### Препроцесорни директиви
---
Това е код, предшеставн от символ '#'. Преди процесът на компилация на вашия код, препроцесорът сканира всички ваши файлове и търси подобни директиви, 
за да ги изпълни. Това означа, че тези редове код се изпълняват **преди процесa на компилация**!  

**Как пишем такива директиви?**
Пишат се само на един ред. При срещанто на знак за нов ред препроцесорът спира да счита кода като част от досега прочетената директива. Ако искаме да пишем
на няколко реда използваме **line-break** символа '\'

~~~.cpp
Няколко пример: (Дефиниция на макорси)

#define HEIGHT 10
#define max(a,b) \  // line-break
((a)>(b)?(a):(b))

#undef max     
#undef HEIGHT  // от тук надолу няма да се разпознават като макроси
~~~

### Различните препроцесорни директиви (Това е малка извадка)
- define   - приема <identifier><replace_value>. Заменя **identifier** с **replace_value**;
- ifdef   - приема <identifer>. Проверява дали **identifier** е дефиниран и изпълнява блока;
- ifndef  - обратното на ifdef;
- if/elif - приема условие което трябва да се изпълни с дадени макроси
- endif   - **всеки if/ifdef/ifndef трябва да бъде затворен с endif**
- error   - приключва компилационния процес при изпълнение
- include - при срещането на тази директива съдържанието на header файлва се замества на мястото на диркетивата

**Важно**  
Можем да добавим header файл по два начина
~~~.cpp
#include <header_name.hpp> // претърсва специално място опеределено от компилатора за библиотеки като стандартната на C++.  
#include "header_name.hpp" // претърсва "имплементационно", като най-често взима сегашната директория като root за претърсването по нататък. 
~~~

### Добавяне на header файлове от стандартната библиотека
---

Вече ще използваме следния начин за добавяне на header файлове от стандатната библиотека (**старите варианти също ще работят**)
~~~.cpp
#include <cmath>     // вместо math.h
#include <cstring>   // вместо string.h
#include <cctype>    // вместо ctype.h 
~~~

### Наименовани пространства
---

В **C** бяхме разгледали така наречените **scope-ове** или както вече ще ги наричаме ненаименувани блокове код. При тях ако предефинираме име на променлива тя се скриваше (получаваше се така нареченият shadowing ефект). Наименованите пространства обаче ни дават възможността да преизползваме едни и същи имена на променливи като просто се обърнем към наименуваният блок от код където, тя е дефинирана. Това се случва с така нареченият scope оператор "::" 

В един наименуван блок можем да сложим много неща - функции, класове, структури, променливи и т.н, но това ще разгледаме в последствие

~~~.cpp
using namespace std;

namespace mine
{
  int my_number = 1;
}

int main(void)
{
    int my_number = 2;
    cout << my_number;       // принтира 2
    cout << mine::my_number; // принтира 1
}
~~~

### Вход/Изход
---

В C++ разполагаме със специална библиотека за обработка на вход и изход.   

Изходът ни тук е буфериран, което значи при извеждане във файл/на конзолата и т.н писаното от нас се натрупва в буфер, докато той не бъде изпразнен и съответно изведен в пространството където пишете. Като затова има специални функции като flush или ако използваме терминиращия символ endl.  

За да достъпим библиотеката за I/O, трябва да добавим следния header файл - iostream (Input Output Stream)  

**Много важно**  
Тъй като функциите и класовете, които ще използваме са част от стандартната библиотека, ще трябва да използваме абривиетурата std за достъп до тях и оператор за принадлежност "::". Това е така, тъй като тези фунцкии и по-нататък класове са декларирани и дефинирани в наименованото пространство **std**.

~~~.cpp
// Пример за вход
#include <iostream>

int main(void)
{
    int a;
    double b;
    char str[10];

    // Четем с оператор >>
    // Като той изрично пропуска празното пространство и може да чете разнотипни променливи
    std::cin >> a >> b; 

    std::cin >> str;           // ВНИМАВАЙТЕ, няма защита от писане в несъществуваща памет, това ще счупи потока при преливане!!!
    std::cin.getline(str,10);  // Това гарантира безопасно четене. Спира на първият знак ' ' или до края на буфера
}

// Пример за изход
#include <iostream>

int main(void)
{
    int age = 10;
    char name[] = "Slim Shady";

    std::cout << "My name is: " << name << '\n' << "My age is: " << age << std::endl; // endl изчиства буфера

    // Ако искате само нов ред пишете '\n', много по-бързо е, тъй като не зачиства буфера!
}
~~~
  
**Важно допълнение**  
Винаги можете да **"using namespace std"**, това ще ви спести да пишете std:: пред всяка функция от стандартната библиотека, но така и ще добавите абсолютно всичко, което се съдържа в самата библиотека. Вие не го виждате, но кодът се добавя, затова никъде другаде извън учебни цели няма да видите това написано. Затова и Ви моля да не го пишете. Създавайте си добри навици!

### Function Overloading  

За разлика от **C** в **C++** можем да имам функции с еднакви имена, но с различен прототип. Нека разгледаме с примери:

~~~.cpp

// Тези двете функции са еднакви за нашия компилатор, тъй като две функции не могат да се различват само и единствено по типа на връщане
int      do_smth(int a, int b);
double   do_smth(int a, int b);

// Задължително трябва да имаме промяна или в броя на аргументите или в тип им
int     do_smth(int b, char str[]);
int     do_smth();
~~~



