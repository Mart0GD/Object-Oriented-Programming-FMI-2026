## Преход към C++. Разлики и новости.

### Препроцесорни директиви
---
Това е код, предшеставн от символ '#'. Преди процесът на компилация на вашия код, препроцесорът сканира всички ваши файлове и търси подобни директиви, 
за да ги изпълни. Това означа, че тези редове код се изпълняват **преди процесa на компилация**!  

**Как пишем такива директиви?**
Пишат се само на един ред. При срещанто на знак за нов ред препроцесорът спира да счита кода като част от досега прочетената директива. Ако искаме да пишем
на няколко реда използваме **line-break** символа '\'

~~~.cpp
Няколко пример: (Дефиниция на макорси)

#define HEIGHT 10
#define max(a,b) \  // line-break
((a)>(b)?(a):(b))

#undef max     
#undef HEIGHT  // от тук надолу няма да се разпознават като макроси
~~~

### Различните препроцесорни директиви (Това е малка извадка)
- define   - приема <identifier><replace_value>. Заменя **identifier** с **replace_value**;
- ifdef   - приема <identifer>. Проверява дали **identifier** е дефиниран и изпълнява блока;
- ifndef  - обратното на ifdef;
- if/elif - приема условие което трябва да се изпълни с дадени макроси
- endif   - **всеки if/ifdef/ifndef трябва да бъде затворен с endif**
- error   - приключва компилационния процес при изпълнение
- include - при срещането на тази директива съдържанието на header файлва се замества на мястото на диркетивата

**Важно**  
Можем да добавим header файл по два начина
~~~.cpp
#include <header_name.hpp> // претърсва специално място опеределено от компилатора за библиотеки като стандартната на C++.  
#include "header_name.hpp" // претърсва "имплементационно", като най-често взима сегашната директория като root за претърсването по нататък. 
~~~

### Добавяне на header файлове от стандартната библиотека
---

Вече ще използваме следния начин за добавяне на header файлове от стандатната библиотека (**старите варианти също ще работят**)
~~~.cpp
#include <cmath>     // вместо math.h
#include <cstring>   // вместо string.h
#include <cctype>    // вместо ctype.h 
~~~

### Наименовани пространства
---

В **C** бяхме разгледали така наречението **scope-ове** или както вече можем да ги наречем ненаименувани блокове код. При тях ако предефинираме име на променлива тя се скриваше (получаваше се така нареченият shadowing). Наименованите пространства обаче ни дават възможността да преизползваме едни и същи имена на променливи като просто се обърнем към наименуваният блок от код където, тя е дефинирана. Това се случва с така нареченият scope оператор "::" 

### Вход/Изход
---

В C++ разполагаме с буфериран подход за обработка на вход и изход 



